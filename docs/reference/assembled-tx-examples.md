# AssembledTransaction Examples

This guide demonstrates how to use the various static methods of `AssembledTransaction` for different smart contract interaction scenarios.

**Note: It is recommended to use [contract bindings](https://developers.stellar.org/docs/learn/fundamentals/contract-development/types/fully-typed-contracts#stellar-js-sdk-contractclient) generated by the [stellar cli](https://developers.stellar.org/docs/tools/cli/install-cli) to handle the creation of `AssembledTransaction`**

## Table of Contents

- [Basic Usage with `build()`](#basic-usage-with-build)
- [Custom Operations with `buildWithOp()`](#custom-operations-with-buildwithop)
- [Serialization with `toJSON()` and `fromJSON()`](#serialization-with-tojson-and-fromjson)
- [XDR Serialization with `toXDR()` and `fromXDR()`](#xdr-serialization-with-toxdr-and-fromxdr)
- [Multi-Auth Workflows](#multi-auth-workflows)
- [Error Handling](#error-handling)

---

## Basic Configuration
This will be the base configuration reused throughout these examples
```typescript
const invoker = Keypair.random() / KeyPair.fromSecret("S....");
const config = {
  networkPassphrase: Networks.TESTNET,
  rpcUrl: 'https://soroban-testnet.stellar.org',
  publicKey: invoker.publicKey(),
  signTransaction: basicNodeSigner(invoker, Networks.TESTNET).signTransaction,
  signAuthEntry: basicNodeSigner(invoker, Networks.TESTNET).signAuthEntry
  parseResultXdr: (xdr: xdr.ScVal) => scValToNative(xdr),
}
```

## Basic Usage with `build()`

The `build()` static method is the most common way to create an `AssembledTransaction`. It constructs and simulates a contract method invocation.

### Simple Read Call

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';
import { Networks } from '@stellar/stellar-sdk';


// Read-only call (no signing needed)
const tx = await AssembledTransaction.build({
  method: 'get_balance',
  args: [
    nativeToScVal(invoker.publicKey(), {type: "address"})
  ],
  contractId: Asset.native().contractId(Networks.TESTNET),
  ...config
});

// Access the result immediately (simulation only)
console.log('Balance:', tx.result);
```

### Simple Write Call

```typescript
import { Keypair, basicNodeSigner, nativeToScVal, Asset } from '@stellar/stellar-sdk';
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

// Write call (requires signing and sending)
const alice = Keypair.random();
const tx = await AssembledTransaction.build({
    method: 'transfer',
    args: [
        nativeToScVal(invoker.publicKey(), { type: 'address' }), // from
        nativeToScVal(alice.publicKey(), { type: 'address' }), // to
        nativeToScVal('100', { type: 'i128' }), // amount
    ],
    contractId: Asset.native().contractId(Networks.TESTNET),
    ...config
});

// Sign and send the transaction
const sentTx = await tx.signAndSend();
console.log('Transaction hash:', sentTx.hash);

// Wait for the result
const result = await sentTx.getTransactionResponse;
console.log('Result:', result);
```

### Skipping Simulation

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

// Build without automatic simulation
const tx = await AssembledTransaction.build({
  method: 'my_method',
  args: [],
  contractId: 'CCONT...',
  simulate: false, // Skip automatic simulation
  ...config,
});

// Now simulate
await tx.simulate();

console.log('Simulated result:', tx.result);
```

---

## Custom Operations with `buildWithOp()`

Use `buildWithOp()` for non-contract-invoking transactions such as restoring, contract uploading and deploying.

The following `Operations` are allowed
- invokeHostFunction
  - createCustomContract
  - createStellarAssetContract
  - uploadContractWasm
  - invokeContractFunction
- restoreFootprint
- extendFootprintTtl


### Deploying a Contract

```typescript
import { Operation, Asset } from '@stellar/stellar-sdk';
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

// Deploy a Stellar Asset Contract
const assetOp = Operation.createStellarAssetContract({
  asset: new Asset('TEST', invoker.publicKey()),
  source: invoker.publicKey()
});

const deployTx = await AssembledTransaction.buildWithOp(
  assetOp,
  {
    publicKey: issuer.publicKey(),
    contractId: '', // Not needed for deployment
    method: 'deploy', // Method name for tracking
    ...config
  }
);

const sentTx = await deployTx.signAndSend();
console.log('Contract deployed at:', sentTx.result);
```

### Upload Contract WASM

```typescript
import { Operation } from '@stellar/stellar-sdk';
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';
import fs from 'fs';

const wasmBytes = fs.readFileSync('./contract.wasm');
const installOp = Operation.uploadContractWasm({
  wasm: wasmBytes,
  source: invoker.publicKey()
});

const installTx = await AssembledTransaction.buildWithOp(
  installOp,
  {
    contractId: '',
    method: 'install_wasm',
    ...config
  }
);

const result = await installTx.signAndSend();
console.log('WASM hash:', result.result);
```

---

## Serialization with `toJSON()` and `fromJSON()`

These methods are essential for multi-auth workflows where a transaction needs to be passed between different parties for signing.

### Serializing a Transaction

```typescript
import { Operation, Keypair } from '@stellar/stellar-sdk';
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

// Invoker creates and simulates a transaction
const bob = Keypair.random();
const tx = await AssembledTransaction.build({
  method: 'multi_sig_transfer',
  args: [
    nativeToScVal(invoker.publicKey(), {type: "address"}),
    nativeToScVal(bob.publicKey(), type: "address"),
    nativeToScVal(1000n, {type: "i128"})
  ],
  contractId: 'CCONT...',
  ...config
});

// Check who else needs to sign
const needsSigning = tx.needsNonInvokerSigningBy();
console.log('Needs signatures from:', needsSigning); // ['GBOB...']

// Serialize to JSON for transmission
const txJson = tx.toJSON();

// Send to Bob (via WebSocket, HTTP, etc.)
sendToBob(txJson);
```

### Deserializing a Transaction

```typescript
import { Operation, Keypair } from '@stellar/stellar-sdk';
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';
// Bob receives the JSON from the Invoker
const txJson = receiveFromAlice();
const bob = Keypair.random();
// Deserialize back to AssembledTransaction
const tx = AssembledTransaction.fromJSON(
  {
    networkPassphrase: Networks.TESTNET,
    rpcUrl: 'https://soroban-testnet.stellar.org',
    publicKey: bob.publicKey(),
    contractId: 'CCONT...',
    parseResultXdr: (xdr) => scValToNative(xdr),
    signAuthEntry: basicNodeSigner(bob, Networks.TESTNET).signAuthEntry
  },
  JSON.parse(txJson)
);

// Bob signs the auth entries
await tx.signAuthEntries();

// Serialize and send back to Alice
const signedJson = tx.toJSON();
sendToInvoker(signedJson);
```

## XDR Serialization with `toXDR()` and `fromXDR()`

XDR serialization provides a more compact format than JSON, useful for storage or bandwidth-constrained scenarios.

### Serializing to XDR

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

const tx = await AssembledTransaction.build({
  method: 'increment',
  args: [],
  contractId: 'CCONT...',
  ...config
});

// Serialize to base64-encoded XDR
const xdrString = tx.toXDR();
console.log('XDR:', xdrString);

```

### Deserializing from XDR

```typescript
import { Spec, rpc } from '@stellar/stellar-sdk/contract';
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';
// Need a contract spec to parse the result
const server = new rpc.Server("https://soroban-testnet.stellar.org")
const contractWasm = await server.getContractWasmByContractId("CCONT...");
const spec = await Spec.fromWasm(contractWasm);

// Deserialize
const tx = AssembledTransaction.fromXDR(
  {
    contractId: '', // The contract id will retrieved when deserialized 
    ...config
  },
  xdrString,
  spec
);

// Requires resimulation
await tx.simulate();

// Continue with signing and sending
await tx.signAndSend();
```

---

## Multi-Auth Workflows

Soroban supports multi-signature transactions where multiple parties must approve.

### Checking Who Needs to Sign

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';
const tx = await AssembledTransaction.build({
  method: 'multi_party_operation',
  args: [
    nativeToScVal("GPARTY1...", {type: "address"}),
    nativeToScVal("GPARTY2...", {type: "address"}),
    nativeToScVal("GPARTY3...", {type: "address"}),
  ],
  contractId: 'CCONT...',
  ...config
});

// Check who needs to sign (excluding the invoker)
const signers = tx.needsNonInvokerSigningBy();
console.log('Required signatures:', signers);
// ['GPARTY2...', 'GPARTY3...']

// Include already-signed entries if needed
const allSigners = tx.needsNonInvokerSigningBy({
  includeAlreadySigned: true
});
```

---

## Error Handling

`AssembledTransaction` provides specific error types for common failure scenarios.

### Handling Specific Errors

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

try {
  const tx = await AssembledTransaction.build({
    method: 'some_method',
    args: [],
    contractId: 'CCONT...',
    ...config,
  });
  
  await tx.signAndSend();
  
} catch (error) {
  if (error instanceof AssembledTransaction.Errors.ExpiredState) {
    console.error('Contract state expired, needs restoration');
    // Handle restoration
    
  } else if (error instanceof AssembledTransaction.Errors.NeedsMoreSignatures) {
    console.error('Transaction needs additional signatures:', error.message);
    // Collect more signatures
    
  } else if (error instanceof AssembledTransaction.Errors.NoSignatureNeeded) {
    console.log('This is a read-only call');
    // Just use the result
    
  } else if (error instanceof AssembledTransaction.Errors.SimulationFailed) {
    console.error('Simulation failed:', error.message);
    // Check contract state or arguments
    
  } else if (error instanceof AssembledTransaction.Errors.UserRejected) {
    console.log('User rejected the transaction');
    // Show user-friendly message
    
  } else {
    console.error('Unexpected error:', error);
  }
}
```

### Manual State Restoration

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';
import { Api } from '@stellar/stellar-sdk/rpc'
const tx = await AssembledTransaction.build({
  method: 'method_with_storage',
  args: [],
  contractId: 'CCONT...',
  ...config,
});

// Check if restoration is needed
if (tx.simulation && Api.isSimulationRestore(tx.simulation)) {
  console.log('State restoration required');
  
  // Manually restore
  const restoreResult = await tx.restoreFootprint(
    tx.simulation.restorePreamble
  );
  
  if (restoreResult.status === Api.GetTransactionStatus.SUCCESS) {
    console.log('State restored successfully');
    
    // Re-simulate with restored state
    await tx.simulate({ restore: false });
  }
}

await tx.signAndSend();
```

### Read Call Detection

```typescript
import { AssembledTransaction } from '@stellar/stellar-sdk/contract';

const tx = await AssembledTransaction.build({
  method: 'get_data',
  args: [],
  contractId: 'CCONT...',
  ...config
});

// Check if this is a read-only call
if (tx.isReadCall) {
  console.log('Read-only call, no signing needed');
  console.log('Result:', tx.result);
} else {
  console.log('Write call, needs signing');
  await tx.signAndSend();
}
```

---

## Advanced Patterns

### Transaction Watchers

```typescript
import { AssembledTransaction, Watcher } from '@stellar/stellar-sdk/contract';

const watcher: Watcher = {
  onSubmitted: (hash) => {
    console.log('Transaction submitted:', hash);
    updateUI({ status: 'pending', hash });
  },
  onProgress: (attempt, timeWaiting) => {
    console.log(`Attempt ${attempt}, waiting ${timeWaiting}ms`);
    updateUI({ status: 'waiting', attempt, timeWaiting });
  }
};

const tx = await AssembledTransaction.build({
  method: 'transfer',
  args: [
    nativeToScVal(invoker.publicKey(), {type: "address"}),
    nativeToScVal("GTO...", {type: "address"}),
    nativeToScVal(1000n, {type: "i128"}),
  ],
  contractId: Asset.native().contractId(Networks.TESTNET),
  ...config
});

const sentTx = await tx.signAndSend({ watcher });
console.log('Transaction completed:', sentTx.hash);
```

### Custom Timeouts and Fees

```typescript
const tx = await AssembledTransaction.build({
  method: 'expensive_operation',
  args: [],
  contractId: 'CCONT...',
  fee: '10000', // Higher fee for priority
  timeoutInSeconds: 60, // 1 minute timeout instead of default 5 minutes
  ...config
});

await tx.signAndSend();
```

### Separate Signing and Sending

```typescript
const tx = await AssembledTransaction.build({
  method: 'transfer',
  args: [],
  contractId: 'CCONT...',
  ...config
});

// Sign first
await tx.sign();

// Inspect the signed transaction
console.log('Signed transaction:', tx.signed?.toXDR());

// Send later
const sentTx = await tx.send();

// Or use a watcher when sending
const sentTxWithWatcher = await tx.send(watcher);
```
